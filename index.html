<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Cal's Modpacks</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;max-width:900px;margin:28px auto;padding:0 16px;color:#111}
    body.dark{background:#222;color:#eee}
    h1{font-size:22px;margin:0 0 8px}
    input{padding:6px;margin:8px 6px 8px 0}
    button{padding:6px}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{border:1px solid #ddd;padding:8px;text-align:left}
    body.dark th, body.dark td{border-color:#555}
    th{background:#f7f7f7}
    body.dark th{background:#444}
    .muted{color:#666;font-size:13px}
    body.dark .muted{color:#aaa}
    .error{color:#a00}
    body.dark .error{color:#f88}
  </style>
</head>
<body>
  <h1>Cal's Modpacks</h1>
  <div class="muted">Repository: callenflynn/Modpacks. All modpacks are for Prism Launcher.</div>
  <div style="margin-top:10px">
    <input id="search" placeholder="Search release tags" aria-label="search">
    <button id="refresh">Refresh</button>
    <button id="darkModeToggle">Toggle Dark Mode</button>
  </div>
  <div id="status" class="muted">Loading…</div>
  <table id="table" aria-live="polite">
    <thead>
      <tr><th>Tag</th><th>Published</th><th>Link</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const owner = 'callenflynn';
    const repo = 'Modpacks';
    const search = document.getElementById('search');
    const refresh = document.getElementById('refresh');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const status = document.getElementById('status');
    const tbody = document.querySelector('#table tbody');
    let releases = [];

    refresh.addEventListener('click', load);
    search.addEventListener('input', renderFiltered);
    darkModeToggle.addEventListener('click', toggleDarkMode);

    if (localStorage.getItem('darkMode') === 'true') {
      document.body.classList.add('dark');
    }

    async function load(){
      status.textContent = 'Loading releases…';
      tbody.innerHTML = '';
      try{
        releases = await fetchAllReleases(owner, repo);
        renderFiltered();
        status.textContent = 'Found ' + releases.length + ' releases';
      }catch(err){
        status.innerHTML = '<span class="error">Error: ' + (err && err.message || err) + '</span>';
      }
    }

    async function fetchAllReleases(owner, repo){
      const token = window.GH_TOKEN || null;
      const headers = { 'Accept': 'application/vnd.github.v3+json' };
      if (token) headers['Authorization'] = 'token ' + token;
      let page = 1; const per_page = 100; const out = [];
      while (true) {
        status.textContent = 'Loading page ' + page + '...';
        const url = 'https://api.github.com/repos/' + owner + '/' + repo + '/releases?per_page=' + per_page + '&page=' + page;
        const res = await fetch(url, { headers });
        if (res.status === 403) {
          const rl = res.headers.get('X-RateLimit-Remaining');
          if (rl === '0') throw new Error('GitHub API rate limit exceeded. Add window.GH_TOKEN and refresh.');
        }
        if (!res.ok) throw new Error('GitHub API returned ' + res.status + ' ' + res.statusText);
        const items = await res.json();
        if (!Array.isArray(items)) throw new Error('Unexpected API response');
        for (const r of items) {
          out.push({ tag: r.tag_name || r.name || '', url: r.html_url || '', published: r.published_at || r.created_at || '' });
        }
        const link = res.headers.get('link') || '';
        if (link.indexOf('rel="next"') === -1) break;
        page += 1;
      }
      return out;
    }

    function renderFiltered(){
      const q = (search.value || '').trim().toLowerCase();
      tbody.innerHTML = '';
      const filtered = releases.filter(r => (r.tag || '').toLowerCase().indexOf(q) !== -1);
      if (filtered.length === 0) {
        const tr = document.createElement('tr');
        const td = document.createElement('td'); td.colSpan = 3; td.textContent = 'No results';
        tr.appendChild(td); tbody.appendChild(tr); return;
      }
      for (const r of filtered) {
        const tr = document.createElement('tr');
        const tdTag = document.createElement('td'); tdTag.textContent = r.tag; tr.appendChild(tdTag);
        const tdDate = document.createElement('td'); tdDate.textContent = r.published ? new Date(r.published).toLocaleString() : 'unknown'; tr.appendChild(tdDate);
        const tdLink = document.createElement('td'); const a = document.createElement('a'); a.href = r.url; a.target = '_blank'; a.rel = 'noopener noreferrer'; a.textContent = 'Release'; tdLink.appendChild(a); tr.appendChild(tdLink);
        tbody.appendChild(tr);
      }
    }

    function toggleDarkMode(){
      document.body.classList.toggle('dark');
      localStorage.setItem('darkMode', document.body.classList.contains('dark'));
    }

    load().catch(err => { status.innerHTML = '<span class="error">Error: ' + (err && err.message || err) + '</span>'; });
  </script>
</body>
</html>
